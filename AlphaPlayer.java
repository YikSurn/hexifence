import java.io.PrintStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Random;

import aiproj.hexifence.Move;
import aiproj.hexifence.Piece;
import aiproj.hexifence.Player;

/*
 *  Alpha-beta player
 *  Makes moves based on alpha-beta pruning
 */
public class AlphaPlayer implements Player, Piece {

    private Board board;
    private int player;
    private int boardDimension;
    private char cellIdentity;

    /* This function is called by the referee to initialize the player.
     *  Return 0 for successful initialization and -1 for failed one.
     */
    @Override
    public int init(int n, int p) {
        if (p != BLUE && p != RED) {
            return INVALID;
        }

        this.player = p;
        this.boardDimension = n;
        this.board = new Board(this.boardDimension);

        return 0;
    }

    @Override
    public Move makeMove() {
        // int THRESHOLD = 6;
        Move m = new Move();

        Point capturePoint = this.board.pointToCaptureCell();
        if (capturePoint != null) {
            m.P = this.player;
            m.Row = capturePoint.getX();
            m.Col = capturePoint.getY();
        // } else if (board.getPossibleMoves() <= THRESHOLD) {
        //     // Start invoking minimax
        //     HashMap<Integer, Move> myBestMove = minimax(this.board, THRESHOLD, this.player);
        //     // Return Move generated by minimax algorithm
        //     m = myBestMove.get(myBestMove.keySet().toArray()[0]);
        } else {
            ArrayList<Edge> edgesToRandomFrom;

            ArrayList<Edge> safeEdges = this.board.getSafeEdges();
            if (safeEdges.size() == 0) {
                edgesToRandomFrom = this.board.getAllUncapturedEdges();
            } else {
                edgesToRandomFrom = safeEdges;
            }

            int numEdges = edgesToRandomFrom.size();

            Random random = new Random();
            int indexEdgeChosen = random.nextInt(numEdges);
            Point chosenPoint = edgesToRandomFrom.get(indexEdgeChosen).getPoint();

            m.P = this.player;
            m.Row = chosenPoint.getX();
            m.Col = chosenPoint.getY();
        }

        this.board.update(m);
        return m;
    }

    /* A simple alpha beta pruning algorithm */
    public int alphaBeta(char[][] boardState,int depth, int alpha, int beta, boolean maxPlayer) {
        int bestValue;
        Move bestMove;
        ArrayList<Move> moves = generateMoves(boardState);

        // Base case: at leaf node
        if (depth == 0 || moves.isEmpty()) {
            return evaluateBoardState(boardState);
        }

        if (maxPlayer) {
            bestValue = Integer.MIN_VALUE;
            for (Move move: moves) {
                Board childBoard = generateChildBoard(move, board);
                bestValue = max(bestValue, alphaBeta(childBoard, depth - 1, alpha, beta, FALSE));
                alpha = max(alpha, bestValue);
                if (beta <= alpha) {
                    break;
                }
            }
            return bestValue;
        } else {
            bestValue = Integer.MAX_VALUE;
            for (Move move: moves) {
                Board childBoard = generateChildBoard(move, board);
                bestValue = min(bestValue, alphaBeta(childBoard, depth - 1, alpha, beta, TRUE));
                beta = min(beta, bestValue);
                if (beta <= alpha) {
                    break;
                }
            }
            return bestValue;
        }
//      for(Move move: nextMoves) {
//          char[][] newBoardState = generateState(move);
//          // Recursive call
//          int result = alphaBetaPruning(newBoardState, alpha, beta, depth-1);
//          if (result > bestScore) {
//              bestScore = result;
//          }
//
//          // Check for cut-off
//
//          alpha = Math.max(alpha, bestScore);
//      }

        // Update history score for best move

        // Return best score
        // return bestScore;
    }

    /* Evaluate a boardState and return an integer that represents
     * the utility of this player
     * */
    private int evaluateBoardState(Board boardState) {
        int numCapturedCells = 0;
        HashMap<Edge, ArrayList<Cell>> edgeToCells =  boardState.getEdgeToCells();
        for(Edge edge: edgeToCells.keySet()) {
            for (Cell cell: edgeToCells.get(edge)) {
                if (cell.getCapturedBy() == cellIdentity) {
                    numCapturedCells += 1;
                }
            }
        }
        return numCapturedCells/2 + 1;
    }

    /* Generate a list of all legal moves of existing boardState
     * */
    private ArrayList<Move> generateMoves(Board board) {
        ArrayList<Move> allLegalMoves = new ArrayList<Move>();
        char[][] boardState = board.getBoardIn2DArray();
        int boardSize = board.calcBoardSize();

        for (int row = 0; row < boardSize; row++) {
            for (int col = 0; col < boardSize; col++) {
                // Represents a possible move that's available for capture
                if (boardState[row][col] == '+') {
                    Move legalMove = new Move();
                    legalMove.P = this.player;
                    legalMove.Row = row;
                    legalMove.Col = col;
                    allLegalMoves.add(legalMove);
                }
            }
        }
        return allLegalMoves;
    }

    /* Generate a new boardState based on a new move made by player */
    //  private char[][] generateState(Move move) {
    //
    //  }

    /* Function called by referee to inform the player about the opponent's move
     * Return -1 if the move is illegal otherwise return 0 if no cell has been
     * captured by the opponent and return 1 if one or more cells are captured
     * by the opponent
     */
    @Override
    public int opponentMove(Move m) {
        Point point = new Point(m.Row, m.Col);

        // Check for invalidity
        if (m.P == this.player) {
            // Check if opponent incorrectly labelled the move as player's own move
            return INVALID;
        } else if (!this.board.validPoint(point)) {
            return INVALID;
        }

        // Opponent's move is valid, check if the move captures a cell
        int value;
        if (this.board.isCapturingPoint(point)) {
            value = 1;
        } else {
            // No cell has been captured
            value = 0;
        }

        // Record the move and update board
        this.board.setLastOpponentPoint(point);
        this.board.update(m);
        return value;
    }

    /* This function when called by referee should return the winner
     *  Return -1, 0, 1, 2, 3 for INVALID, EMPTY, BLUE, RED, DEAD respectively
     */
    @Override
    public int getWinner() {
        return this.board.getWinner();
    }

    /* Function called by referee to get the board configuration in String format
     *
     */
    @Override
    public void printBoard(PrintStream output) {
        this.board.printBoard();
    }
}
